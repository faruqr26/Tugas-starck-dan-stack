TUGAS !
SOURCE CODE : 
#include <stdio.h>


// Mendefinisikan struct Batu untuk menyimpan HURUF  
struct Batu {
    char HURUF;  // Menyimpan huruf pada batu
    struct Batu *link;  // Pointer ke Batu berikutnya dalam urutan
};

int main() {
    // Inisialisasi batu 
    struct Batu l1, l2, l3, l4, l5, l6, l7, l8, l9;

    l1.link = NULL;
    l1.HURUF = 'F';

    l2.link = NULL;
    l2.HURUF = 'M';

    l3.link = NULL;
    l3.HURUF = 'A';

    l4.link = NULL;
    l4.HURUF = 'I';

    l5.link = NULL;
    l5.HURUF = 'K';

    l6.link = NULL;
    l6.HURUF = 'T';

    l7.link = NULL;
    l7.HURUF = 'N';

    l8.link = NULL;
    l8.HURUF = 'O';

    l9.link = NULL;
    l9.HURUF = 'R';


    // Mengatur koneksi 
    l7.link = &l1;
    l1.link = &l8;
    l8.link = &l2;
    l2.link = &l5;
    l5.link = &l3;
    l3.link = &l6;
    l6.link = &l9;
    l9.link = &l4;
    l4.link = &l7;


    // Mengakses huruf pada batu menggunakan l3 sebagai titik awal
    printf("%c", l3.link->link->link->HURUF); 
    printf("%c", l3.link->link->link->link->HURUF);
    printf("%c", l3.link->link->link->link->link->HURUF);
    printf("%c", l3.link->link->link->link->link->link->HURUF);
    printf("%c", l3.link->link->HURUF);
    printf("%c", l3.link->link->link->link->link->link->link->HURUF);
    printf("%c", l3.HURUF); 
    printf("%c", l3.link->HURUF); 
    printf("%c", l3.link->link->link->HURUF); 
    printf("%c", l3.link->link->link->link->link->link->link->link->HURUF); 
    printf("%c", l3.HURUF);

    return 0;
}




TUGAS 2

SOURCE CODE : 

#include <stdio.h>

// Fungsi untuk mencari nilai maksimum dari dua bilangan
int max(int a, int b) {
    return a > b ? a : b;
}

// Fungsi untuk mencari jumlah maksimum elemen yang dapat diambil dari kedua stack
int twoStacks(int maxSum, int a[], int m, int b[], int n) {
    int total = 0, count = 0, maxCount = 0;
    int i = 0, j = 0;

    // Iterasi untuk mengambil elemen dari kedua stack
    while (i < m && total + a[i] <= maxSum) {
        total += a[i++];
        count++;
        maxCount = max(maxCount, count);
    }

    // Iterasi sambil mempertimbangkan elemen dari stack kedua
    while (j < n && i >= 0) {
        total += b[j++];
        count++;

        // Jika total melebihi maxSum, kurangi elemen dari stack pertama
        while (total > maxSum && i > 0) {
            i--;
            total -= a[i];
            count--;
        }

        // Perbarui maxCount jika jumlah saat ini lebih besar
        if (total <= maxSum) {
            maxCount = max(maxCount, count);
        }
    }

    return maxCount;
}

int main() {
    int games;
    scanf("%d", &games);

    for (int g = 0; g < games; g++) {
        int m, n, maxSum;
        scanf("%d %d %d", &m, &n, &maxSum);
        int a[m], b[n];

        // Masukkan elemen stack pertama
        for (int i = 0; i < m; i++) {
            scanf("%d", &a[i]);
        }

        // Masukkan elemen stack kedua
        for (int i = 0; i < n; i++) {
            scanf("%d", &b[i]);
        }

        // Cetak hasil jumlah maksimum elemen yang dapat diambil
        printf("%d\n", twoStacks(maxSum, a, m, b, n));
    }

    return 0;
}

